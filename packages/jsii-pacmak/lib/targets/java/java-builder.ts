import * as fs from 'fs-extra';
import * as path from 'path';
import * as xmlbuilder from 'xmlbuilder';

import { BuildOptions, TargetBuilder } from '../../builder';
import * as logging from '../../logging';
import { JsiiModule } from '../../packaging';
import { findLocalBuildDirs, Target } from '../../target';
import { Scratch, setExtend, slugify } from '../../util';
import { VERSION_DESC } from '../../version';
import Java from '../java';
import { TemporaryJavaPackage } from './temporary-java-package';

/**
 * Build Java packages all together, by generating an aggregate POM
 *
 * This will make the Java build a lot more efficient (~300%).
 *
 * Do this by copying the code into a temporary directory, generating an aggregate
 * POM there, and then copying the artifacts back into the respective output
 * directories.
 */
export class JavaBuilder implements TargetBuilder {
  private readonly targetName = 'java';

  public constructor(
    private readonly modules: readonly JsiiModule[],
    private readonly options: BuildOptions,
  ) {}

  public async buildModules(): Promise<void> {
    if (this.modules.length === 0) {
      return;
    }

    if (this.options.codeOnly) {
      // Simple, just generate code to respective output dirs
      await Promise.all(
        this.modules.map((module) =>
          this.generateModuleCode(
            module,
            this.options,
            this.outputDir(module.outputDirectory),
          ),
        ),
      );
      return;
    }

    // Otherwise make a single tempdir to hold all sources, build them together and copy them back out
    const scratchDirs: Array<Scratch<any>> = [];
    try {
      const tempSourceDir = await this.generateAggregateSourceDir(
        this.modules,
        this.options,
      );
      scratchDirs.push(tempSourceDir);

      // Need any old module object to make a target to be able to invoke build, though none of its settings
      // will be used.
      const target = this.makeTarget(this.modules[0], this.options);
      const tempOutputDir = await Scratch.make(async (dir) => {
        logging.debug(`Building Java code to ${dir}`);
        await target.build(tempSourceDir.directory, dir);
      });
      scratchDirs.push(tempOutputDir);

      await this.copyOutArtifacts(
        tempOutputDir.directory,
        tempSourceDir.object,
      );

      if (this.options.clean) {
        await Scratch.cleanupAll(scratchDirs);
      }
    } catch (e) {
      logging.warn(
        `Exception occurred, not cleaning up ${scratchDirs
          .map((s) => s.directory)
          .join(', ')}`,
      );
      throw e;
    }
  }

  private async generateModuleCode(
    module: JsiiModule,
    options: BuildOptions,
    where: string,
  ): Promise<void> {
    const target = this.makeTarget(module, options);
    logging.debug(`Generating Java code into ${where}`);
    await target.generateCode(where, module.tarball);
  }

  private async generateAggregateSourceDir(
    modules: readonly JsiiModule[],
    options: BuildOptions,
  ): Promise<Scratch<TemporaryJavaPackage[]>> {
    return Scratch.make(async (tmpDir: string) => {
      logging.debug(`Generating aggregate Java source dir at ${tmpDir}`);
      const ret: TemporaryJavaPackage[] = [];

      const generatedModules = modules
        .map((module) => ({ module, relativeName: slugify(module.name) }))
        .map(({ module, relativeName }) => ({
          module,
          relativeName,
          sourceDir: path.join(tmpDir, relativeName),
        }))
        .map(({ module, relativeName, sourceDir }) =>
          this.generateModuleCode(module, options, sourceDir).then(() => ({
            module,
            relativeName,
          })),
        );

      for await (const { module, relativeName } of generatedModules) {
        ret.push({
          relativeSourceDir: relativeName,
          relativeArtifactsDir: moduleArtifactsSubdir(module),
          outputTargetDirectory: module.outputDirectory,
        });
      }

      await this.generateAggregatePom(
        tmpDir,
        ret.map((m) => m.relativeSourceDir),
      );
      await this.generateMavenSettingsForLocalDeps(tmpDir);

      return ret;
    });
  }

  private async generateAggregatePom(where: string, moduleNames: string[]) {
    const aggregatePom = xmlbuilder
      .create(
        {
          project: {
            '@xmlns': 'http://maven.apache.org/POM/4.0.0',
            '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
            '@xsi:schemaLocation':
              'http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd',
            '#comment': [
              `Generated by jsii-pacmak@${VERSION_DESC} on ${new Date().toISOString()}`,
            ],

            modelVersion: '4.0.0',
            packaging: 'pom',

            groupId: 'software.amazon.jsii',
            artifactId: 'aggregatepom',
            version: '1.0.0',

            modules: {
              module: moduleNames,
            },
          },
        },
        { encoding: 'UTF-8' },
      )
      .end({ pretty: true });

    logging.debug(`Generated ${where}/pom.xml`);
    await fs.writeFile(path.join(where, 'pom.xml'), aggregatePom);
  }

  private async copyOutArtifacts(
    artifactsRoot: string,
    packages: TemporaryJavaPackage[],
  ) {
    logging.debug('Copying out Java artifacts');
    // The artifacts directory looks like this:
    //  /tmp/XXX/software/amazon/awscdk/something/v1.2.3
    //                                 /else/v1.2.3
    //                                 /entirely/v1.2.3
    //
    // We get the 'software/amazon/awscdk/something' path from the package, identifying
    // the files we need to copy, including Maven metadata. But we need to recreate
    // the whole path in the target directory.

    await Promise.all(
      packages.map(async (pkg) => {
        const artifactsSource = path.join(
          artifactsRoot,
          pkg.relativeArtifactsDir,
        );
        const artifactsDest = path.join(
          this.outputDir(pkg.outputTargetDirectory),
          pkg.relativeArtifactsDir,
        );

        await fs.mkdirp(artifactsDest);
        await fs.copy(artifactsSource, artifactsDest, { recursive: true });
      }),
    );
  }

  /**
   * Decide whether to append 'java' to the given output directory
   */
  private outputDir(declaredDir: string) {
    return this.options.languageSubdirectory
      ? path.join(declaredDir, this.targetName)
      : declaredDir;
  }

  /**
   * Generates maven settings file for this build.
   * @param where The generated sources' directory. This is where user.xml will be placed.
   */
  private async generateMavenSettingsForLocalDeps(where: string) {
    const filePath = path.join(where, 'user.xml');

    // traverse the dep graph of this module and find all modules that have
    // an <outdir>/java directory. we will add those as local maven
    // repositories which will resolve instead of Maven Central for those
    // module. this enables building against local modules (i.e. in lerna
    // repositories or linked modules).
    const allDepsOutputDirs = new Set<string>();

    const resolvedModules = this.modules.map(async (mod) => ({
      module: mod,
      localBuildDirs: await findLocalBuildDirs(
        mod.moduleDirectory,
        this.targetName,
      ),
    }));
    for await (const { module, localBuildDirs } of resolvedModules) {
      setExtend(allDepsOutputDirs, localBuildDirs);

      // Also include output directory where we're building to, in case we build multiple packages into
      // the same output directory.
      allDepsOutputDirs.add(
        path.join(
          module.outputDirectory,
          this.options.languageSubdirectory ? this.targetName : '',
        ),
      );
    }

    const localRepos = Array.from(allDepsOutputDirs);

    // if java-runtime is checked-out, and we can find a local repository,
    // add it to the list.
    const localJavaRuntime = await findJavaRuntimeLocalRepository();
    if (localJavaRuntime) {
      localRepos.push(localJavaRuntime);
    }

    logging.debug('local maven repos:', localRepos);

    const profileName = 'local-jsii-modules';

    const localRepository = this.options.arguments['maven-local-repository'];

    // noinspection HttpUrlsUsage
    const settings = xmlbuilder
      .create(
        {
          settings: {
            '@xmlns': 'http://maven.apache.org/POM/4.0.0',
            '@xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
            '@xsi:schemaLocation':
              'http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd',
            '#comment': [
              `Generated by jsii-pacmak@${VERSION_DESC} on ${new Date().toISOString()}`,
            ],
            // Do *not* attempt to ask the user for stuff...
            interactiveMode: false,
            // Use a non-default local repository (unless java-custom-cache-path arg is provided) to isolate from cached artifacts...
            localRepository: localRepository
              ? path.resolve(process.cwd(), localRepository)
              : path.resolve(where, '.m2', 'repository'),
            // Register locations of locally-sourced dependencies
            profiles: {
              profile: {
                id: profileName,
                repositories: {
                  repository: localRepos.map((repo) => ({
                    id: repo.replace(/[\\/:"<>|?*]/g, '$'),
                    url: `file://${repo}`,
                  })),
                },
              },
            },
            activeProfiles: {
              activeProfile: profileName,
            },
          },
        },
        { encoding: 'UTF-8' },
      )
      .end({ pretty: true });

    logging.debug(`Generated ${filePath}`);
    await fs.writeFile(filePath, settings);
    return filePath;
  }

  private makeTarget(module: JsiiModule, options: BuildOptions): Target {
    return new Java({
      arguments: options.arguments,
      assembly: module.assembly,
      fingerprint: options.fingerprint,
      force: options.force,
      packageDir: module.moduleDirectory,
      rosetta: options.rosetta,
      runtimeTypeChecking: options.runtimeTypeChecking,
      targetName: this.targetName,
    });
  }
}

/**
 * Return the subdirectory of the output directory where the artifacts for this particular package are produced
 */
function moduleArtifactsSubdir(module: JsiiModule) {
  const groupId = module.assembly.targets!.java!.maven.groupId;
  const artifactId = module.assembly.targets!.java!.maven.artifactId;
  return `${groupId.replace(/\./g, '/')}/${artifactId}`;
}

/**
 * Looks up the `@jsii/java-runtime` package from the local repository.
 * If it contains a "maven-repo" directory, it will be added as a local maven repo
 * so when we build locally, we build against it and not against the one published
 * to Maven Central.
 */
function findJavaRuntimeLocalRepository() {
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires,@typescript-eslint/no-require-imports,import/no-extraneous-dependencies
    const javaRuntime = require('@jsii/java-runtime');
    logging.info(
      `Using local version of the Java jsii runtime package at: ${javaRuntime.repository}`,
    );
    return javaRuntime.repository;
  } catch {
    return undefined;
  }
}
